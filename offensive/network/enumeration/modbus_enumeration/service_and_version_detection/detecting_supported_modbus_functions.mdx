---
title: Detecting Supported Modbus Functions in Industrial Networks
description: Learn to detect supported Modbus functions through packet crafting and
  response analysis for enhanced industrial cybersecurity.
keywords:
- Modbus functions
- function code detection
- packet crafting
- Modbus protocol
- industrial cybersecurity
- network enumeration
- Modbus communication
- response analysis
- automation scripting
- vulnerability assessment
---

# Detecting Supported Modbus Functions

## Understanding Modbus Function Codes

Modbus, a widely used industrial communication protocol, employs function codes to specify actions to be performed on or by a slave device. Each function code corresponds to a specific operation, such as reading from discrete inputs, writing to coils, or obtaining device diagnostics. The commonly used function codes range from 1 to 127, with each code performing specific tasks:

- **Read Coils (Function Code 1):** This function reads a sequence of coils or outputs from a Modbus device.
- **Read Discrete Inputs (Function Code 2):** Retrieves the status of discrete inputs.
- **Read Holding Registers (Function Code 3):** Gets data from holding registers often used for storing runtime data.
- **Read Input Registers (Function Code 4):** Collects analog data input from sensors.

Modbus communication involves a request-response cycle wherein a master device sends a request to perform a specific function, and the slave device responds with either the requested data or an error code signaling unsupported or failed operations. Understanding the structure of these request and response packets is key to detecting supported Modbus functions effectively.

## Packet Crafting for Function Code Testing

Crafting Modbus request packets involves using precise network tools to send well-formed packets to the target device, testing for supported function codes. Constructing these packets requires knowledge of the Modbus TCP protocol format, which typically includes a unit identifier, function code, reference number, and data byte count, if applicable.

To create and send Modbus packets with varied function codes, tools like Scapy, Metasploit, or even custom Python scripts can be utilized. Here is an example of a Python script using Scapy to craft and send these packets:

```python
from scapy.all import *
from scapy.contrib.modbus import *

target_ip = "192.168.1.10"
function_code = 1  # Example of Read Coils

# Crafting a Modbus packet
modbus_packet = ModbusADUrequest(transId=1, unitId=1, PDU=ModbusPDU01ReadCoilsReq(startAddr=0, quantity=10))

# Sending the packet
send(IP(dst=target_ip)/TCP(dport=502)/modbus_packet)
```

Modifying the function codes in this script allows operators to systematically test each function code to determine support across different Modbus devices.

## Interpreting Modbus Response Behavior

Upon sending packets with various function codes, analyzing the behavior of Modbus responses is crucial. Supported function codes will typically elicit a normal response, containing the requested data. Conversely, unsupported functions generate specific error codes as part of the Modbus Exception Response. These errors can include:

- **Illegal Function (Exception Code 1):** The function code is not supported by the relevant slave device.
- **Illegal Data Address (Exception Code 2):** The data address specified in the request is invalid.
- **Illegal Data Value (Exception Code 3):** The data value provided is not acceptable.

By recognizing these responses, security professionals can accurately determine which Modbus functions are supported, aiding in network security assessments and potential vulnerability analyses.

## Automation of Detection Processes

Automating the detection process for supported Modbus functions involves scripting to send multiple requests with various function codes and handling the responses systematically. Python, combined with libraries like Scapy, allows security professionals to automate this task, facilitating comprehensive assessments across multiple devices or large networks. The following script automates the sending of Modbus requests for a series of function codes, logging responses for further analysis:

```python
function_codes = [1, 2, 3, 4, 5, 6, 15, 16]
responses = {}

for code in function_codes:
    packet = ModbusADUrequest(transId=1, unitId=1, PDU=ModbusPDU(code))
    response = sr1(IP(dst="192.168.1.10")/TCP(dport=502)/packet, timeout=2, verbose=False)
    responses[code] = response

print(responses)
```

This script efficiently tests support for each function code and logs the outcome, streamlining the detection process and enabling easier interpretation of results.

## Logging and Analyzing Test Outcomes

Analyzing and logging responses is critical to identifying supported functions. Network monitoring tools like Wireshark provide detailed packet captures, allowing analysts to view Modbus request-response cycles, error codes, and response times. By logging these metrics, professionals can detect anomalies, identify unsupported functions, and highlight potential security risks.

Reports can be configured to track success rates and response anomalies, with metrics like response times and error code frequencies offering insights into network behaviors and clues about possible security weaknesses.

## Generating Detection Reports

Upon completing the functional support testing, generating comprehensive detection reports is essential. These reports should include the tested function codes, their response statuses, and any detected security weaknesses or operational limitations. Clear and concise reporting allows for effective communication of findings to stakeholders, potentially informing network security strategies and guiding further protective measures.

## Remediation Strategies

Upon detecting vulnerabilities or unsupported functions, ensuring robust remediation strategies is crucial. This may involve notifying network administrators of detected weaknesses and suggesting security enhancements. Recommendations might include implementing firewalls to block unsupported function codes, 

using intrusion detection systems to monitor and log unauthorized attempts, or employing periodic assessments to ensure the continued integrity and security of Modbus communication channels. Additionally, continuous monitoring policies can be established for ongoing Modbus network analysis to address vulnerabilities promptly and maintain security standards.