---
title: Exploit XPath Functions for XML Data Extraction
description: Learn to exploit XPath functions for extracting and manipulating XML
  data using injection techniques.
keywords:
- XPath functions
- XML data extraction
- XPath injection
- web application exploits
- substring function
- contains function
- normalize-space
- security testing
---

# XPath Functions Exploitation

## Context

The purpose of this article is to demonstrate practical exploitation of XPath functions to extract, infer, or manipulate XML data via injection. This discussion assumes you have a working knowledge of XPath syntax, XML structure, web application architecture, and XPath Injection techniques. 

## Theory

### Abusing XPath Functions in Injection Contexts

XPath functions are designed to process, filter, or transform XML data within queries. When an application exposes user input to XPath queries without proper sanitization, it becomes vulnerable to function-based exploitation. By crafting malicious queries, attackers can manipulate the query logic to leak or infer sensitive data stored in XML documents.

### Key XPath Functions for Exploitation

- **contains(), starts-with(), ends-with()**: These functions are used to test for the presence of specific strings or prefixes/suffixes within targeted data.
- **normalize-space(), translate()**: These functions help in bypassing filters or normalizing data extracted from XML documents.
- **concat()**: This function joins multiple strings, which can be useful for constructing complex payloads.
- **count(), position()**: These functions allow enumeration of nodes or infer the structure of the XML.
- **string-length(), substring(), substring-before(), substring-after()**: Utilized for character-by-character data extraction, these functions can be crucial for understanding the structure and content of the XML data.

### Function-Based Data Extraction Logic

- Use boolean functions to infer data through true/false query responses.
- Employ string manipulation functions to extract specific characters or substrings, piece by piece.
- Combine different functions to bypass input validation or obfuscate injected payloads, hiding them from simple detection measures.

## Practice

### Extracting Data with contains() and substring()

To infer sensitive information such as passwords, you can use the `contains()` and `substring()` functions to ask the system specific queries about its content:

- Use the following XPath payload to check if the password of the first user contains the letter 'a':
  ```xpath
  ' or contains(/users/user[1]/password,'a') or '1'='0
  ```
- Use this extraction method to check if a particular character is at the start of a password:
  ```xpath
  ' or substring(/users/user[1]/password,1,1)='a' or '1'='0
  ```

When successful, these queries allow you to infer password contents character by character based on true/false responses from the application.

### Bypassing Filters with normalize-space() and translate()

With `normalize-space()` and `translate()`, attackers can adjust input data to pass validation filters:

- Normalize the username input to remove excess whitespace:
  ```xpath
  ' or normalize-space(/users/user[1]/username)='admin' or '1'='0
  ```
- Translate uppercase to lowercase to force a case-insensitive match:
  ```xpath
  ' or translate(/users/user[1]/username,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')='admin' or '1'='0
  ```

Implementing these queries can help in bypassing input validation restrictions, thus aiding successful injection attempts.

### Enumerating Nodes with count() and position()

These functions are invaluable for discovering the number and arrangement of nodes within the XML structure:

- Confirm if there are two user nodes in the system:
  ```xpath
  ' or count(/users/user)=2 or '1'='0
  ```
- Target the first node starkly:
  ```xpath
  ' or /users/user[position()=1] or '1'='0
  ```

Employing these methods can uncover structural vulnerabilities and help craft more refined attack strategies.

### Combining concat() and substring() for Obfuscated Extraction

By utilizing `concat()` and `substring()`, an attacker can extract multiple characters at once, thus forming complex queries:

- Fetch and verify the first two characters together:
  ```xpath
  ' or concat(substring(/users/user[1]/password,1,1),substring(/users/user[1]/password,2,1))='ab' or '1'='0
  ```

This technique enables extracting multiple characters through concatenated comparison, potentially bypassing naive detection filters focused on simpler patterns.

## Tools

- **Burp Suite**
- **OWASP ZAP**
- **curl** 

These tools assist in constructing, testing, and automating XPath function-based exploitations.