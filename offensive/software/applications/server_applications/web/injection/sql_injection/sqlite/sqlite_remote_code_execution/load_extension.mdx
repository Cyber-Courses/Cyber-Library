---
title: Exploiting SQLite's Load_extension for RCE
description: Explore how to exploit SQLite's load_extension for remote code execution
  in SQL injection scenarios.
keywords:
- SQLite
- load_extension
- remote code execution
- SQL injection
- dynamic library loading
- shared object injection
- security mechanisms
---

# Load_extension

## Context

In this article, we will explore how to exploit SQLite's `load_extension` function to achieve remote code execution (RCE). To follow along, you should have a solid understanding of SQLite architecture, shared libraries, dynamic loading, and prior experience with SQLite Remote Code Execution techniques. This guide is designed for those familiar with these concepts, simplifying the path to using this vulnerability effectively.

## Theory

### SQLite Load_extension Functionality

The `load_extension` function in SQLite is designed to enhance SQLite's capabilities by loading shared libraries. This function allows the database to incorporate additional, custom functions by dynamically loading those defined in the shared libraries.

### Dynamic Library Loading in SQLite

Dynamic library loading refers to the process where SQLite loads a shared library at runtime, extending the core functionality of the database. However, if an attacker can control the input to this function, it might lead to arbitrary library loading, which is a common vector for exploitation. The typical method of attack involves using SQL injection to supply the `load_extension` function with a path to a malicious library designed to execute arbitrary code.

### Shared Object Injection

Injecting a shared object involves creating a `.so` file, which is essentially a compiled library designed to be loaded at runtime. In the context of SQLite and SQL injection, a malicious actor can craft a `.so` file containing harmful code and use `load_extension` to execute it. This circumvents usual security checks and controls by acting within the typical operation parameters of the database.

### Security Mechanisms and Bypasses

SQLite was designed with the trust assumption that only authorized and knowledgeable users would load extensions. In an offensive context, bypassing input filters to inject `load_extension` statements becomes key. Attackers aim to circumvent these input validations to load their crafted shared objects, exploiting the trust mechanisms in place.

## Practice

### Exploiting load_extension for RCE

To exploit the `load_extension` function in SQLite for remote code execution, follow these steps:

1. **Compile a Malicious Shared Object File**

    First, create and compile a malicious `.so` file. This file should contain the arbitrary code that you wish to execute within the SQLite environment.

    ```bash
    gcc -shared -o /tmp/malicious.so -fPIC malicious.c
    ```

    This command uses `gcc` to compile a C source file (`malicious.c`) into a shared object file (`/tmp/malicious.so`). The `-shared` flag indicates that the output should be a shared library, and `-fPIC` is used to ensure position-independent code, necessary for shared objects.

2. **Inject SQL to Load the Malicious Shared Object**

    With the shared object file in place, the next step is to execute an SQL command that triggers the `load_extension` function with the path to your malicious file.

    ```bash
    sqlite3 'file:exploit.db?mode=memory&cache=shared' "SELECT load_extension('/tmp/malicious.so');"
    ```

    In this command, `sqlite3` is used to run an SQL command on an in-memory database. The SQL command calls `load_extension` with the path to the malicious shared object, loading it into the SQLite process.

    **Outcome**: This exploit results in remote code execution, as the functions or actions defined in the malicious shared object are executed by SQLite.

## Tools

- **gcc**
- **sqlite3** 

These tools are essential for compiling the shared object and executing the SQL commands necessary for the attack.