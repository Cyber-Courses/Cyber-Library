# PHP SSRF pentesting


# 👉 Overview

---

### 👀 What ?

Server Side Request Forgery (SSRF) is a vulnerability that allows an attacker to force a server to perform requests on their behalf. In the context of PHP, this is particularly relevant as PHP is a widely used server-side scripting language.


### 🧐 Why ?

SSRF attacks can have serious consequences, allowing attackers to bypass access controls, such as firewalls, to interact with internal services, perform actions on behalf of the server or access sensitive data. As such, understanding and testing for SSRF vulnerabilities is a crucial part of ensuring the security of any PHP application.


### ⛏️ How ?

To test for SSRF vulnerabilities in PHP, one can use a variety of methods, such as injecting malicious payloads into vulnerable parameters and observing the response, using automated tools, or through manual code review. Techniques include exploiting file handling functions, utilizing PHP wrappers, and manipulating URL schemas.


### ⏳ When ?

SSRF vulnerabilities have been a concern since the early days of web development, but they've gained particular attention in the PHP community over the past decade as the language's use has grown and its features have become more complex.


# ⚙️ Technical Explanations

---

Server-Side Request Forgery (SSRF) vulnerabilities are a significant security concern, particularly in the context of PHP, a commonly utilized server-side scripting language. SSRF vulnerabilities arise when a PHP script accepts user-provided input, like URLs, IP addresses, or other network identifiers, and uses this in a network call.

In an ideal scenario, the PHP script should properly validate and sanitize such input to prevent any malicious manipulation. However, if this is not done, an attacker can exploit this oversight to manipulate the input and make the server perform unintended network requests. These manipulated requests will be performed with the server's privileges, thereby allowing the attacker to access internal resources or perform actions as though they were the server itself. This is a serious breach as it can allow attackers to bypass access controls such as firewalls, interact with internal services, or access sensitive data.

To test for SSRF vulnerabilities in PHP, various methods can be employed. Attackers may inject malicious payloads into vulnerable parameters and observe the response, use automated tools, or conduct a manual code review. Techniques may include exploiting file handling functions, utilizing PHP wrappers, and manipulating URL schemas.

To mitigate the potential risks associated with SSRF vulnerabilities, it's recommended to implement strict input validation, utilize allow-lists for network calls, and ensure that potentially dangerous PHP functions are not used unsafely. By doing so, the server can be better equipped to prevent the manipulation of user-supplied input and avoid unintended network requests.

SSRF vulnerabilities have been a concern since the early days of web development but have garnered particular attention in the PHP community over the past decade as the language's use has grown and its features have become more complex. The ongoing evolution of PHP and its features necessitates a continuous and thorough understanding and testing of potential SSRF vulnerabilities to ensure the security of PHP applications.

Let's consider a PHP application that fetches an image from a URL provided by the user and displays it on the webpage. The PHP script might look something like this:

```php
<?php
$url = $_GET['url'];
$data = file_get_contents($url);
echo "<img src='data:image/jpeg;base64,".base64_encode($data)."'";
?

```

In this script, the `file_get_contents` function fetches content from the URL provided by the user. If the user provides a URL of a legitimate image, the script will function as expected.

However, this script is vulnerable to SSRF attacks because it doesn't validate or sanitize the user input. An attacker could provide a URL that points to a sensitive internal resource. For example, if the attacker provides the URL `http://localhost/admin`, the script would fetch and display the admin page.

To mitigate this vulnerability, the script should validate the user-provided URL. Here's an improved version of the script:

```php
<?php
$url = $_GET['url'];

// Validate the URL
if (!filter_var($url, FILTER_VALIDATE_URL)) {
    die('Invalid URL');
}

// Only allow URLs that point to images
if (!preg_match('/\\.(jpg|jpeg|png|gif)$/', parse_url($url, PHP_URL_PATH))) {
    die('Invalid URL');
}

$data = file_get_contents($url);
echo "<img src='data:image/jpeg;base64,".base64_encode($data)."'";
?

```

This updated script validates the URL and only allows URLs that point to images. This reduces the risk of SSRF attacks, but it's not a complete solution. For even better security, the script should use an allow-list of safe domains and should avoid using functions that can make network calls with user-supplied input.
