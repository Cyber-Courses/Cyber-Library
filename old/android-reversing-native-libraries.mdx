# Android Reversing Native Libraries


# 👉 Overview

---

### 👀 What ?

> Android Reversing Native Libraries is a process that involves examining the compiled native libraries of an Android application in order to understand their functionality. Native Libraries are parts of an application that are written in languages like C and C++, which are then compiled into machine-readable code. This is different from the usual Java-based Android applications that are compiled into bytecode, which runs on the Android Runtime (ART) or Dalvik virtual machine.
> 

### 🧐 Why ?

> Understanding the functionality of native libraries is crucial for developers and security researchers as they can contain critical parts of the application's functionality, including security-related functions. Furthermore, vulnerabilities within these libraries can lead to serious security issues, making them a common target for attackers. Through reversing these libraries, one can find potential security flaws and fix them to make the application more secure.
> 

### ⛏️ How ?

> To reverse Android native libraries, one would typically use tools such as IDA Pro, Ghidra, or Radare2, which can disassemble the compiled code into a more human-readable format. This disassembled code can then be analyzed to understand the functionality of the library. It is important to have a good understanding of the programming language that the library is written in, as well as knowledge of Android's operating system and its interaction with native libraries.
> 

### ⏳ When ?

> Reversing of Android native libraries began to gain traction with the increased use of native code in Android applications for performance-critical tasks. With the rise in cyber threats and the need for secure applications, the practice has become more prevalent in recent years.
> 

# ⚙️ Technical Explanations

---

Native libraries in Android applications are usually written in C or C++, which are then compiled into an Executable and Linkable Format (ELF) file. Unlike Java bytecode, which is more straightforward to understand, this machine code can be quite complex.

These native libraries often play a critical role in an application’s performance and functionality, including the implementation of security-related functions. As such, any vulnerabilities within these libraries could potentially lead to serious security breaches, making them a prime target for attackers. Hence, the process of reversing or decompiling these libraries is essential to identify and rectify these potential vulnerabilities, thereby enhancing the overall security of the application.

To reverse Android native libraries, one would typically use tools such as IDA Pro, Ghidra, or Radare2. These tools disassemble the compiled machine code into Assembly language, a low-level language that is somewhat easier to understand than raw machine code.

Assembly language is a type of low-level language that provides a common representation of machine code, which can be used for developing, debugging, and reverse-engineering software. It is symbolic representation of the numeric machine codes and other constants needed to program a particular CPU architecture. This disassembled code can then be analyzed to understand the functionality of the library, identify any potential security issues, and get a deeper insight into the application's overall functionality.

It is important to note that a good understanding of the programming language in which the library is written, along with knowledge of Android's operating system and its interaction with native libraries, is essential when attempting to reverse Android native libraries.

In recent years, the practice of reversing Android native libraries has grown in popularity. This is due to the increased use of native code in Android applications for performance-critical tasks, coupled with the rise in cyber threats and the growing need for secure applications.

Let's consider an example where we attempt to reverse a native library from a fictitious Android application called `MyApp`. Suppose `libMyNative.so` is our native library written in C++.

Step 1: **Extract the APK file**

First, we need to get the APK file of the application. This can be done using the `adb` command as shown below:

```
adb pull /data/app/com.example.MyApp-1/base.apk

```

Step 2: **Unpack the APK file**

Next, we unpack the APK file to access the native library. We can use the `unzip` command for this:

```
unzip base.apk

```

After unzipping, we navigate to the `lib` directory where we can find our target `libMyNative.so` file.

Step 3: **Disassemble the library**

Now, we disassemble the library using a disassembler tool like Ghidra. Here's a command-line way to do it using `objdump`:

```
objdump -D libMyNative.so > disassembly.txt

```

This command will create a text file `disassembly.txt` containing the Assembly code of the library.

Step 4: **Analyze the disassembled code**

Now, we start analyzing the disassembled code. This process involves understanding the Assembly instructions, function calls, string references, and more. For example, if we find a function that deals with password validation, we can look for potential security vulnerabilities like buffer overflows.

Please note that the given commands serve as an illustrative example and might not work as intended depending on the specifics of the Android application and the native library. This process involves a deep understanding of Assembly language, the C or C++ programming language, and the Android operating system's interaction with native libraries.
