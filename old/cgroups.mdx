# CGroups


# 👉 Overview

---

### 👀 What ?

> Linux CGroups, also known as control groups, is a Linux kernel feature designed to limit, police, and account the resource usage for processes. These resources include CPU, memory, disk I/O, network, etc. It is one of the fundamental concepts that underpin the working of Linux containers and orchestration tools like Docker and Kubernetes.
> 

### 🧐 Why ?

> In a system where multiple processes are running, it becomes crucial to have a mechanism for resource allocation and management. Without such a mechanism, a single process could potentially consume all the available resources, causing other processes to starve or the entire system to crash. This is where CGroups comes into play. It provides a way to control the distribution of system resources among processes, making the system more stable and efficient.
> 

### ⛏️ How ?

> To make use of CGroups, you would need to mount the cgroup filesystem and create control groups. Each control group has a set of parameters that you can modify to limit resources. For example, you can set 'cpu.shares' to determine how much CPU time a group should get, or 'memory.limit_in_bytes' to set a limit on memory usage. Once you've configured your cgroups, you can add processes to them by writing the process's PID to the 'cgroup.procs' file.
> 

### ⏳ When ?

> The concept of CGroups was introduced in Linux kernel version 2.6.24, which was released in 2008. Since then, it has been a vital part of the Linux ecosystem, especially with the rise of containerization and cloud computing.
> 

# ⚙️ Technical Explanations

---

CGroups, or control groups, is a Linux kernel feature that provides a mechanism for efficiently managing and allocating system resources. The central concept revolves around grouping processes and applying the same resource limits and constraints to all processes within a group.

The Linux kernel attaches a cgroup to a set of processes, allowing uniform control over the resource allocation among these processes. The kernel keeps track of each cgroup's resource usage to enforce the user-defined limits effectively. This tracking ensures no single process or group of processes consumes an excessive amount of resources, which could lead to system instability or crashes.

In addition to basic resource management, CGroups features a mechanism known as 'cgroup hierarchy'. This allows for nested cgroups, meaning you can have a parent cgroup containing child cgroups, each with its own unique set of resource limits. This hierarchical structure offers enhanced flexibility in resource management, allowing for more granular control over resource allocation.

For example, a parent cgroup might have a high-level limit on CPU usage, but within that parent cgroup, child cgroups could have their own unique CPU limits. This hierarchical structure ensures that resources are shared fairly among all processes, preventing any single process or group of processes from monopolizing system resources.

CGroups is a fundamental concept that underpins many modern Linux-based technologies, including containerization tools like Docker and Kubernetes. Understanding and effectively utilizing CGroups is crucial for anyone working with these technologies or managing system resources on Linux-based systems.

Let's consider a practical example of using CGroups:

1. **Mount the cgroup filesystem**
    
    First, you need to mount the cgroup filesystem. Open a terminal and run the following command:
    
    ```
    sudo mount -t cgroup cgroup /cgroup
    
    ```
    
    This command mounts the cgroup filesystem at the `/cgroup` directory.
    
2. **Create a new control group**
    
    Next, you create a new control group. For this example, let's create a cgroup called `mygroup`:
    
    ```
    sudo mkdir /cgroup/mygroup
    
    ```
    
    This command creates a new directory for the `mygroup` cgroup in the cgroup filesystem.
    
3. **Set resource limits**
    
    Now, you can set resource limits for this cgroup. Let's set a limit on CPU usage:
    
    ```
    echo 500 > /cgroup/mygroup/cpu.shares
    
    ```
    
    This command sets the `cpu.shares` parameter to `500`, which means the `mygroup` cgroup will get 50% of the CPU time.
    
4. **Add a process to the cgroup**
    
    Finally, you can add a process to the cgroup. You do this by writing the process's PID to the `cgroup.procs` file:
    
    ```
    echo $$ > /cgroup/mygroup/cgroup.procs
    
    ```
    
    This command adds the current shell process to the `mygroup` cgroup.
    

Remember that the exact parameters available to you will depend on the specific controllers that are enabled in your cgroup filesystem. The above example is a basic illustration, and real-world usage will often involve more complex configurations and multiple nested cgroups.
